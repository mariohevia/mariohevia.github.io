<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Seven Years Later: Refactoring the Code Behind My First Peer-Reviewed Paper | Dr. Mario A. Hevia Fajardo</title> <meta name="author" content="Mario A. Hevia Fajardo"> <meta name="description" content="I revisit the code from my first peer-reviewed paper (and master's thesis), published seven years ago, to modernize it with the skills and knowledge I’ve gained since, improving its performance, readability, and maintainability."> <meta name="keywords" content="evolutionary-computation, evolutionary-algorithms, runtime-analysis, research, theory"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://mariohevia.github.io/blog/2025/refactoring-code-behind-first-peer-reviewed-paper/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Seven Years Later: Refactoring the Code Behind My First Peer-Reviewed Paper",
      "description": "I revisit the code from my first peer-reviewed paper (and master's thesis), published seven years ago, to modernize it with the skills and knowledge I’ve gained since, improving its performance, readability, and maintainability.",
      "published": "February 1, 2025",
      "authors": [
        {
          "author": "Mario A. Hevia Fajardo",
          "authorURL": "https://mhevia.com",
          "affiliations": [
            {
              "name": "University of Birmingham",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Dr. Mario A. Hevia Fajardo</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right font-weight-bold" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Home</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Seven Years Later: Refactoring the Code Behind My First Peer-Reviewed Paper</h1> <p>I revisit the code from my first peer-reviewed paper (and master's thesis), published seven years ago, to modernize it with the skills and knowledge I’ve gained since, improving its performance, readability, and maintainability.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#what-does-the-original-code-do">What does the original code do?</a></div> <div><a href="#what-i-did-right">What I did right?</a></div> <div><a href="#improvements">Improvements</a></div> <div><a href="#is-the-code-s-behavior-preserved">Is the code's behavior preserved?</a></div> <div><a href="#runtime-comparisons">Runtime comparisons</a></div> <div><a href="#conclusions">Conclusions</a></div> </nav> </d-contents> <p>After seven years of programming and learning, I decided to revisit one of my first major Python projects, because I want to reuse it for a new project. Although I had been programming in Python for over a year at the time, I was still relatively new to it and many things can be improved in the codebase. Therefore, my plan is to refactor and modernise the code in order to be able to reporpose it and at the same time improve its runtime using GPUs.</p> <p>In this post, I’ll share what I think I did right, and what steps I took to improve it.</p> <h3 id="what-does-the-original-code-do">What does the original code do?</h3> <p>This project was part of my Master’s Thesis and eventually contributed to my <a href="https://doi.org/10.1145/3321707.3321858" rel="external nofollow noopener" target="_blank">first peer-reviewed publication</a> at <a href="https://gecco-2019.sigevo.org/index.html/HomePage" rel="external nofollow noopener" target="_blank">GECCO 2019</a>, the ACM flagship conference in evolutionary computation. In the project I aimed to compare previously published self-adjusting evolutionary algorithms (EAs) and improve upon them. If you are unfamiliar with self-adjusting EAs, don’t worry, I will explain it in simple terms.</p> <p>EAs are optimisation algorithms that mimic evolution to search for a solution to a problem. They work similar to trial and error: you start with a set of solutions, then randomly modify (mutate) or combine (crossover) them. Next, you update your current set of solutions based on how well they perform, compared to the initial solutions, finally, you repeat the process until you find a good solution. While the idea is simple, there are many different EAs, and each comes with parameters like the number of solutions created every iteration (offspring population) or how much the new solutions are changed (mutation and crossover rate), and the parameter settings can greatly affect their performance.</p> <p>When using an EA, practitioners can either select the parameters at the start of the run (which remain fixed throughout) or let the algorithm adjust them on its own. Self-adjusting EAs fall into the latter category—they automatically choose their parameters without human input. If you’re interested in this topic, you can read more in my <a href="self-adjusting">PhD thesis</a>.</p> <p>That said, the code implements several well-known and some new self-adjusting EAs and compares their optimisation times (calculated by the number of function evaluations) on various optimisation problems.</p> <h3 id="what-i-did-right">What I did right?</h3> <p>I think that, overall, the code is pretty good. It is well written, and I even did documentation for it, which helped this time around.</p> <p>Here are the things I think I did right:</p> <ul> <li>The algorithms and the optimisation problems are implemented as classes with a consistent structure, making them interchangable and allowing new algorithms/problems to be added without changing the main file.</li> <li>The project is relatively well-structured. Here is the file structure: <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">code</span><span class="o">/</span> 
<span class="err">├──</span> <span class="n">master</span><span class="p">.</span><span class="n">py</span>           <span class="c1"># Main script
</span><span class="err">├──</span> <span class="n">utils</span><span class="o">/</span> 
  <span class="err">├──</span> <span class="n">inputs</span><span class="p">.</span><span class="n">py</span>         <span class="c1"># Parsing command-line parameters
</span>  <span class="err">├──</span> <span class="n">leadingones</span><span class="p">.</span><span class="n">py</span>    <span class="c1"># LeadingOnes problem
</span><span class="bp">...</span>
  <span class="err">├──</span> <span class="n">outputs</span><span class="p">.</span><span class="n">py</span>        <span class="c1"># Plots and output logs
</span>  <span class="err">└──</span> <span class="n">sufsamp</span><span class="p">.</span><span class="n">py</span>        <span class="c1"># SufSamp problem
</span></code></pre></div> </div> </li> <li>Each algorithm and problem is contained in its own file, making it easy to maintain.</li> <li>The main file accepts command-line parameters, providing flexibility for running different experiments.</li> <li>All parameters are validated, with explanations and suggested values provided for invalid inputs.</li> <li>Experiments are logged and plotted automatically after completion. </li> </ul> <h3 id="improvements">Improvements</h3> <p>Although the project has a good structure, there are still many things that can be improved or modernised with new libraries. Let’s go through them by parts.</p> <h4 id="code-structure-modularity-and-reusability">Code structure, modularity and reusability</h4> <p>The current implementation uses two “types of classes”, but there is no template class for them to inherit from. Because of this, the code assumes that certain class methods exist and that specific attributes are created and updated inside the algorithm and problem classes without prior checks. It also directly accesses these attributes outside of the class, which is not good practice.</p> <p>Additionally, the algorithms assume that the representations of the problem’s solutions are strings consisting only of ones and zeroes, which limits the possible representations of a problem. This is done because the mutation and crossover used by the algorithms depend on the problem representation, but this should not be set in stone. A better approach is to let the problem class handle the representation of the problems, including how they can be mutated or combined.</p> <p>Let’s write the two parent classes:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Problem</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement evaluate method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement get_name method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_max_fitness</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement get_max_fitness method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample_uar</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement mutate method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement to_string method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement to_string method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement mutate method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement crossover method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">multiparent_crossover</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement multiparent_crossover method</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Algorithm</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">problem</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_evaluations</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement __next__ method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_num_evaluations</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">num_evaluations</span>

    <span class="k">def</span> <span class="nf">get_best_individual</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement get_best_individual method</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_current_population</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">(</span><span class="sh">"</span><span class="s">Subclass must implement get_best_individual method</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Since the current implementation only deals with pseudo-Boolean problems (bitstring representations), I also implemented a new subclass that handles the mutation and crossover for all these problems. This way, the final classes only include the necessary functions, avoiding boilerplate code. As an example, here I show OneMax, which assigns fitness based on the number of one-bits in the bitstring.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OneMax</span><span class="p">(</span><span class="n">BitstringProblem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">bitstring</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">OneMax</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">get_max_fitness</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span>
</code></pre></div></div> <p>Once all the problems were implemented, I returned to the algorithms. However, for this part, we need to consider possible optimisations.</p> <h4 id="parallelisation-and-optimisations">Parallelisation and optimisations</h4> <p>One of the main goals of revisiting this project is to improve the script’s runtime. Since I first considered refactoring the code, I also planned to enable it to run on a GPU using JAX, which should improve the runtime on its own. However, we also need to identify the parts of the code that take the most time during execution to prioritise optimising these areas.</p> <p>To do that I will use the line-by-line profiling library <a href="https://github.com/pyutils/line_profiler" rel="external nofollow noopener" target="_blank">line_profiler</a>. I installed it with:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>line-profiler
</code></pre></div></div> <p>Once installed, I added the decorator <code class="language-python">@profile</code> to the main function in <code>master.py</code> and then run:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kernprof <span class="nt">-l</span> <span class="nt">-v</span> master.py
</code></pre></div></div> <p>This highlighted that, intuitively, the line that takes the most time is <code class="language-python">next(algorithm)</code>. This is where the script iterates the algorithm.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Line</span>    <span class="n">Hits</span>         <span class="n">Time</span>  <span class="n">Per</span> <span class="n">Hit</span>   <span class="o">%</span> <span class="n">Time</span>  <span class="n">Line</span> <span class="n">Contents</span>
<span class="o">==============================================================</span>
<span class="bp">...</span>
<span class="mi">75</span>       <span class="mi">100</span>         <span class="mf">37.3</span>      <span class="mf">0.4</span>      <span class="mf">0.0</span>          <span class="k">if</span> <span class="n">configuration</span><span class="p">.</span><span class="n">stop_criteria</span> <span class="o">==</span> <span class="sh">'</span><span class="s">solved</span><span class="sh">'</span><span class="p">:</span>
<span class="mi">76</span>       <span class="mi">100</span>        <span class="mf">369.3</span>      <span class="mf">3.7</span>      <span class="mf">0.0</span>              <span class="n">m_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="n">configuration</span><span class="p">.</span><span class="n">problem_size</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1000000</span><span class="p">)</span>
<span class="mi">77</span>    <span class="mi">106957</span>      <span class="mf">18801.5</span>      <span class="mf">0.2</span>      <span class="mf">0.2</span>              <span class="k">while</span> <span class="ow">not</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">solved</span><span class="p">:</span>
<span class="mi">78</span>    <span class="mi">106857</span>    <span class="mf">9996295.9</span>     <span class="mf">93.5</span>     <span class="mf">97.1</span>                  <span class="nf">next</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
<span class="mi">79</span>    <span class="mi">106857</span>      <span class="mf">23680.5</span>      <span class="mf">0.2</span>      <span class="mf">0.2</span>                  <span class="nf">if </span><span class="p">(</span><span class="n">algorithm</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">past_fitness</span><span class="p">):</span>
<span class="mi">80</span>    <span class="mi">102403</span>      <span class="mf">14566.7</span>      <span class="mf">0.1</span>      <span class="mf">0.1</span>                      <span class="n">tol</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="mi">81</span>    <span class="mi">102403</span>      <span class="mf">15213.8</span>      <span class="mf">0.1</span>      <span class="mf">0.1</span>                      <span class="n">tol2</span> <span class="o">+=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">offspring_size</span>
<span class="mi">82</span>                                                           <span class="k">else</span><span class="p">:</span>
<span class="mi">83</span>      <span class="mi">4454</span>        <span class="mf">577.7</span>      <span class="mf">0.1</span>      <span class="mf">0.0</span>                      <span class="n">tol</span> <span class="o">=</span> <span class="mi">0</span>
<span class="mi">84</span>      <span class="mi">4454</span>        <span class="mf">506.4</span>      <span class="mf">0.1</span>      <span class="mf">0.0</span>                      <span class="n">tol2</span> <span class="o">=</span> <span class="mi">0</span>
<span class="mi">85</span>    <span class="mi">106857</span>      <span class="mf">16685.3</span>      <span class="mf">0.2</span>      <span class="mf">0.2</span>                  <span class="n">past_fitness</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">86</span>    <span class="mi">106857</span>      <span class="mf">34697.3</span>      <span class="mf">0.3</span>      <span class="mf">0.3</span>                  <span class="nf">if </span><span class="p">(</span><span class="n">algorithm</span><span class="p">.</span><span class="n">evaluations</span> <span class="o">&gt;</span> <span class="n">m_size</span> <span class="ow">or</span> <span class="n">tol2</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">):</span>
<span class="bp">...</span>
</code></pre></div></div> <p>Although each algorithm performs different tasks, I profiled one of the simplest algorithms to get an idea of which processes take the longest. From the results below, we can see that creating new offspring through mutation and selecting the best offspring take the most time. Therefore, I will focus on these areas when rewriting the code.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Line</span> <span class="c1">#      Hits         Time  Per Hit   % Time  Line Contents
</span><span class="o">==============================================================</span>
<span class="bp">...</span>
<span class="mi">30</span>                                               <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
<span class="mi">31</span>    <span class="mi">108166</span>      <span class="mf">18012.9</span>      <span class="mf">0.2</span>      <span class="mf">0.1</span>          <span class="n">offspring</span> <span class="o">=</span> <span class="p">[]</span>
<span class="mi">32</span>    <span class="mi">216332</span>     <span class="mf">139315.8</span>      <span class="mf">0.6</span>      <span class="mf">0.8</span>          <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">problem</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bit_string</span><span class="p">),</span> 
<span class="mi">33</span>    <span class="mi">108166</span>      <span class="mf">14133.1</span>      <span class="mf">0.1</span>      <span class="mf">0.1</span>                          <span class="n">self</span><span class="p">.</span><span class="n">bit_string</span><span class="p">]</span>
<span class="mi">34</span>    <span class="mi">108166</span>      <span class="mf">19152.2</span>      <span class="mf">0.2</span>      <span class="mf">0.1</span>          <span class="n">self</span><span class="p">.</span><span class="n">mut_prob_gen</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">mutation_probability</span><span class="p">)</span>
<span class="mi">35</span>    <span class="mi">108166</span>      <span class="mf">16763.9</span>      <span class="mf">0.2</span>      <span class="mf">0.1</span>          <span class="n">self</span><span class="p">.</span><span class="n">lambda_gen</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">offspring_size</span><span class="p">)</span>
<span class="mi">36</span>    <span class="mi">216332</span>      <span class="mf">63976.3</span>      <span class="mf">0.3</span>      <span class="mf">0.4</span>          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">offspring_size</span><span class="p">):</span>
<span class="mi">37</span>    <span class="mi">108166</span>   <span class="mf">13799267.8</span>    <span class="mf">127.6</span>     <span class="mf">82.0</span>              <span class="n">mutated_string</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mutate</span><span class="p">()</span>
<span class="mi">38</span>    <span class="mi">216332</span>     <span class="mf">132957.3</span>      <span class="mf">0.6</span>      <span class="mf">0.8</span>              <span class="n">offspring</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">problem</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="n">mutated_string</span><span class="p">),</span> 
<span class="mi">39</span>    <span class="mi">108166</span>      <span class="mf">13945.3</span>      <span class="mf">0.1</span>      <span class="mf">0.1</span>                                <span class="n">mutated_string</span><span class="p">))</span>
<span class="mi">40</span>    <span class="mi">108166</span>    <span class="mf">2534601.8</span>     <span class="mf">23.4</span>     <span class="mf">15.1</span>          <span class="n">self</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>
<span class="mi">41</span>    <span class="mi">108166</span>      <span class="mf">22606.2</span>      <span class="mf">0.2</span>      <span class="mf">0.1</span>          <span class="n">self</span><span class="p">.</span><span class="n">generations</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="mi">42</span>    <span class="mi">108166</span>      <span class="mf">45919.3</span>      <span class="mf">0.4</span>      <span class="mf">0.3</span>          <span class="n">self</span><span class="p">.</span><span class="n">evaluations</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">offspring_size</span>
</code></pre></div></div> <p>The good news from these results is that the tasks taking the most time can be improved through parallelisation. I will now show you how the same function looks in the new code. You’ll notice that I added more comments to make the code more maintainable, and I parallelised the tasks that take the longest.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># Split RNG key for mutation and generate subkeys for each offspring mutation
</span>        <span class="n">self</span><span class="p">.</span><span class="n">rng_key</span><span class="p">,</span> <span class="n">mutate_subkey</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rng_key</span><span class="p">)</span>
        <span class="n">mutate_subkeys</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">mutate_subkey</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">offspring_size</span><span class="p">)</span>

        <span class="c1"># Generate offspring by mutating the parent using parallelisation
</span>        <span class="n">vmap_mutation</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">vmap</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">problem</span><span class="p">.</span><span class="n">mutate</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">offspring</span> <span class="o">=</span> <span class="nf">vmap_mutation</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">mutation_probability</span><span class="p">,</span><span class="n">mutate_subkeys</span><span class="p">)</span>

        <span class="c1"># Combine offspring with the original parent for evaluation
</span>        <span class="n">offspring_parent</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">offspring</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">jnp</span><span class="p">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Split RNG key for evaluation and generate subkeys for each evaluation
</span>        <span class="n">self</span><span class="p">.</span><span class="n">rng_key</span><span class="p">,</span> <span class="n">eval_subkey</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rng_key</span><span class="p">)</span>
        <span class="n">eval_subkeys</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">eval_subkey</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">offspring_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

         <span class="c1"># Evaluate fitness of offspring and parent
</span>        <span class="n">vmap_eval</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">vmap</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">problem</span><span class="p">.</span><span class="n">evaluate</span><span class="p">)</span>
        <span class="n">fitnesses</span> <span class="o">=</span> <span class="nf">vmap_eval</span><span class="p">(</span><span class="n">offspring_parent</span><span class="p">,</span><span class="n">eval_subkeys</span><span class="p">)</span>

        <span class="c1"># Identify the index of the best fitness
</span>        <span class="n">best_index</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">fitnesses</span><span class="p">)</span>

        <span class="c1"># Update the parent, best fitness and number of evaluations used
</span>        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">offspring_parent</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_evaluations</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">offspring_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">best_fitness</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">best_fitness</span><span class="p">,</span> <span class="n">fitnesses</span><span class="p">[</span><span class="n">best_index</span><span class="p">])</span>
</code></pre></div></div> <h3 id="is-the-codes-behavior-preserved">Is the code’s behavior preserved?</h3> <p>Before we start comparing the runtime of both implementations, we need to ensure that the behaviour of the code remains consistent. Since the algorithms are random, the new implementation uses different libraries (with distinct random generators), and I have rewritten several parts of the code, we can’t expect the exact same results, even with the same random seeds. However, we can still test whether the results are consistent on average by running multiple tests.</p> <p>Testing with the same algorithm I showed earlier on OneMax for 100 runs with both implementations, I obtained an average of 125,610 function evaluations with the old code and 125,225 function evaluations with the new one. This suggests that the two are likely to have the same behavior and we can continue to comparing their runtime.</p> <h3 id="runtime-comparisons">Runtime comparisons</h3> <p>The final part is to compare the runtime of the new implementation versus the old one. For these tests, I used the same algorithm-problem pair as before, and we can clearly see a stark difference in performance. One finishes in just over one and a half minutes, while the other takes more than an hour!</p> <p>Here are the results (I’ve removed most of the lines that didn’t take too much time):</p> <h5 id="new-implementation">New implementation</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Total</span> <span class="n">time</span><span class="p">:</span> <span class="mf">101.373</span> <span class="n">s</span>

<span class="n">Line</span> <span class="c1">#      Hits         Time  Per Hit   % Time  Line Contents
</span><span class="o">==============================================================</span>
<span class="bp">...</span>
    <span class="mi">37</span>       <span class="mi">100</span>         <span class="mf">35.3</span>      <span class="mf">0.4</span>      <span class="mf">0.0</span>              <span class="n">case</span> <span class="sh">"</span><span class="s">solved</span><span class="sh">"</span><span class="p">:</span>
    <span class="mi">38</span>     <span class="mi">25145</span>    <span class="mf">2513597.3</span>    <span class="mf">100.0</span>      <span class="mf">2.5</span>                  <span class="k">while</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">best_fitness</span><span class="o">&lt;</span><span class="n">problem</span><span class="p">.</span><span class="nf">get_max_fitness</span><span class="p">():</span>
    <span class="mi">39</span>     <span class="mi">25045</span>   <span class="mf">97746846.7</span>   <span class="mf">3902.8</span>     <span class="mf">96.4</span>                      <span class="nf">next</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
<span class="bp">...</span>
</code></pre></div></div> <h5 id="old-implementation">Old implementation</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Total</span> <span class="n">time</span><span class="p">:</span> <span class="mf">5409.95</span> <span class="n">s</span>

<span class="n">Line</span> <span class="c1">#      Hits         Time  Per Hit   % Time  Line Contents
</span><span class="o">==============================================================</span>
<span class="bp">...</span>
    <span class="mi">76</span>       <span class="mi">100</span>        <span class="mf">376.7</span>      <span class="mf">3.8</span>      <span class="mf">0.0</span>              <span class="n">m_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="n">configuration</span><span class="p">.</span><span class="n">problem_size</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1000000</span><span class="p">)</span>
    <span class="mi">77</span>     <span class="mi">25222</span>       <span class="mf">6507.4</span>      <span class="mf">0.3</span>      <span class="mf">0.0</span>              <span class="k">while</span> <span class="ow">not</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">solved</span><span class="p">:</span>
    <span class="mi">78</span>     <span class="mi">25122</span> <span class="mf">5409583277.1</span> <span class="mf">215332.5</span>    <span class="mf">100.0</span>                  <span class="nf">next</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
<span class="bp">...</span>
</code></pre></div></div> <h3 id="conclusion">Conclusion</h3> <p>The first thing I want to say is that it was so much fun to return to one of my first projects and realise how much I’ve learnt over the last 7 years. The results show that the new implementation not only preserves the behaviour of the original code but also runs much faster, making it more efficient for larger experiments. Now, I can move on to my next project, which will use this new implementation as a base.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Mario A. Hevia Fajardo. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: May 06, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>